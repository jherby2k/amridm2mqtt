#!/usr/bin/env python3
'''
Runs rtlamr to watch for SDM broadcasts from utility meters. If the meter id
is in the list, usage is sent to an MQTT broker under a
'meters/{meter id}/reading' topic. All required settings should be specified in
settings.py.

'''
import os
import subprocess
import signal
import time
import paho.mqtt.client as mqtt
import settings

# Use signal to shut down gracefully
def shutdown(signum, frame):
	print('shutting down')
	rtlamr.terminate()

signal.signal(signal.SIGTERM, shutdown)

# Start the rtl_tcp program
with subprocess.Popen([settings.RTL_TCP + " > /dev/null 2>&1 &"], shell=True, stdin=None, stdout=None, stderr=None, close_fds=True):
	time.sleep(10)
	print('started rtl_tcp')

	# Start the rtlamr program
	filter_ids = ','.join(map(str, settings.WATCHED_METERS))
	rtlamr_cmd = [settings.RTLAMR, '-msgtype=scm', '-format=csv', '-filterid=' + filter_ids, '-symbollength=' + str(settings.SYMBOL_LENGTH)]
	with subprocess.Popen(rtlamr_cmd, stdout=subprocess.PIPE, universal_newlines=True) as rtlamr:
		print('started rtlamr')

		# Connect to the MQTT broker
		client = mqtt.Client('rtlamr')
		if settings.MQTT_TLS:
			client.tls_set()
		if len(settings.MQTT_USER) and len(settings.MQTT_PASSWORD):
			client.username_pw_set(settings.MQTT_USER, settings.MQTT_PASSWORD)
		client.will_set('meters/availability', 'offline', retain=True)
		client.connect(settings.MQTT_HOST, settings.MQTT_PORT)
		client.loop_start()
		client.publish('meters/availability', 'online', retain=True)
		print('connected to broker. Setting availability to "online"')

		# Process messages in a loop
		last_readings = {}
		for line in rtlamr.stdout:
			fields = line.strip().split(',')

			# Valid SCM results have 9 fields
			if len(fields) != 9:
				continue

			# Parse the results
			meter_id = int(fields[3])
			reading = int(fields[7])

			# Don't send a reading if the value hasn't changed
			if meter_id in last_readings.keys() and reading == last_readings[meter_id]:
				continue
			last_readings[meter_id] = reading

			print('sending meter {} reading: {}'.format(meter_id, reading))
			result = client.publish('meters/{}/reading'.format(meter_id), reading, retain=True)

			# If the connection died, reestablish it (last message will still be processed)
			if result.rc == 4: #MQTT_ERR_NO_CONN
				client.reconnect()
				client.publish('meters/availability', 'online', retain=True)
				print('reconnected to broker')

		# Clean up after rtlamr exits
		print('setting availability to "offline"')
		result = client.publish('meters/availability', 'offline', retain=True)
		result.wait_for_publish()
		client.disconnect()
		client.loop_stop()
